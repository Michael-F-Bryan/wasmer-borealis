interface Node {
  """The ID of the object"""
  id: ID!
}

type PublicKey implements Node {
  """The ID of the object"""
  id: ID!
  owner: User!
  keyId: String!
  key: String!
  revokedAt: DateTime
  uploadedAt: DateTime!
  verifyingSignature: Signature
  revoked: Boolean!
}

type User implements Node & PackageOwner & Owner {
  firstName: String!
  lastName: String!
  email: String!
  dateJoined: DateTime!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  isEmailValidated: Boolean!
  bio: String
  location: String
  websiteUrl: String

  """The ID of the object"""
  id: ID!
  globalName: String!
  globalId: ID!
  avatar(size: Int = 80): String!
  isViewer: Boolean!
  hasUsablePassword: Boolean
  fullName: String!
  githubUrl: String
  twitterUrl: String
  companyRole: String
  companyDescription: String
  publicActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  billing: Billing
  waitlist(name: String!): WaitlistMember
  namespaces(role: GrapheneRole, offset: Int, before: String, after: String, first: Int, last: Int): NamespaceConnection!
  packages(collaborating: Boolean = false, offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(collaborating: Boolean = false, sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  isStaff: Boolean
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  packageInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  namespaceInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  apiTokens(before: String, after: String, first: Int, last: Int): APITokenConnection!
  notifications(before: String, after: String, first: Int, last: Int): UserNotificationConnection!
  dashboardActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  loginMethods: [LoginMethod!]!
}

"""Setup for backwards compatibility with existing frontends."""
interface PackageOwner {
  globalName: String!
  globalId: ID!
}

"""An owner of a package."""
interface Owner {
  globalName: String!
  globalId: ID!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type ActivityEventConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ActivityEventEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `ActivityEvent` and its cursor."""
type ActivityEventEdge {
  """The item at the end of the edge"""
  node: ActivityEvent

  """A cursor for use in pagination"""
  cursor: String!
}

type ActivityEvent implements Node {
  """The ID of the object"""
  id: ID!
  body: EventBody!
  actorIcon: String!
  createdAt: DateTime!
}

type EventBody {
  text: String!
  ranges: [NodeBodyRange!]!
}

type NodeBodyRange {
  entity: Node!
  offset: Int!
  length: Int!
}

type WaitlistMember implements Node {
  waitlist: Waitlist!
  joinedAt: DateTime!
  approvedAt: DateTime

  """The ID of the object"""
  id: ID!
  member: Owner!
  approved: Boolean!
}

type Waitlist implements Node {
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type NamespaceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Namespace` and its cursor."""
type NamespaceEdge {
  """The item at the end of the edge"""
  node: Namespace

  """A cursor for use in pagination"""
  cursor: String!
}

type Namespace implements Node & PackageOwner & Owner {
  """The ID of the object"""
  id: ID!
  name: String!
  displayName: String
  description: String!
  avatar: String!
  avatarUpdatedAt: DateTime
  twitterHandle: String
  githubHandle: String
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
  maintainerInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserConnection!
  globalName: String!
  globalId: ID!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorConnection!
  publicActivity(before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!

  """Whether the current user is invited to the namespace"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the namespace"""
  viewerInvitation: NamespaceCollaboratorInvite
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
}

type NamespaceCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `NamespaceCollaboratorInvite` and its cursor.
"""
type NamespaceCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

type NamespaceCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  namespace: Namespace!
  role: RegistryNamespaceMaintainerInviteRoleChoices!
  accepted: NamespaceCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryNamespaceMaintainerInviteRoleChoices {
  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type NamespaceCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryNamespaceMaintainerRoleChoices!
  namespace: Namespace!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: NamespaceCollaboratorInvite
}

enum RegistryNamespaceMaintainerRoleChoices {
  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type UserConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `User` and its cursor."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Package` and its cursor."""
type PackageEdge {
  """The item at the end of the edge"""
  node: Package

  """A cursor for use in pagination"""
  cursor: String!
}

type Package implements Likeable & Node & PackageOwner {
  """The ID of the object"""
  id: ID!
  name: String!
  private: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  maintainers: [User]! @deprecated(reason: "Please use collaborators instead")
  curated: Boolean!
  ownerObjectId: Int!
  lastVersion: PackageVersion

  """The app icon. It should be formatted in the same way as Apple icons"""
  icon: String!
  totalDownloads: Int!
  iconUpdatedAt: DateTime
  watchersCount: Int!
  webcs(offset: Int, before: String, after: String, first: Int, last: Int): WebcImageConnection!
  versions: [PackageVersion]!
  collectionSet: [Collection!]!
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  keywords(offset: Int, before: String, after: String, first: Int, last: Int): PackageKeywordConnection!
  likersCount: Int!
  viewerHasLiked: Boolean!
  globalName: String!
  globalId: ID!
  alias: String
  namespace: String!
  displayName: String!

  """The name of the package without the owner"""
  packageName: String!

  """The app icon. It should be formatted in the same way as Apple icons"""
  appIcon: String! @deprecated(reason: "Please use icon instead")

  """The total number of downloads of the package"""
  downloadsCount: Int

  """The public keys for all the published versions"""
  publicKeys: [PublicKey!]!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!
  owner: PackageOwner!
  isTransferring: Boolean!
  activeTransferRequest: PackageTransferRequest
  isArchived: Boolean!
  viewerIsWatching: Boolean!
  showDeployButton: Boolean!
  similarPackageVersions(before: String, after: String, first: Int, last: Int): PackageSearchConnection!

  """Whether the current user is invited to the package"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the package"""
  viewerInvitation: PackageCollaboratorInvite
}

interface Likeable {
  id: ID!
  likersCount: Int!
  viewerHasLiked: Boolean!
}

type PackageVersion implements Node {
  """The ID of the object"""
  id: ID!
  package: Package!
  version: String!
  description: String!
  manifest: String!
  license: String
  licenseFile: String
  readme: String
  witMd: String
  repository: String
  homepage: String
  createdAt: DateTime!
  updatedAt: DateTime!
  staticObjectsCompiled: Boolean!
  nativeExecutablesCompiled: Boolean!
  publishedBy: User!
  clientName: String
  signature: Signature
  isArchived: Boolean!
  file: String!

  """"""
  fileSize: BigInt!
  webc: WebcImage
  totalDownloads: Int!
  bindingsState: RegistryPackageVersionBindingsStateChoices!
  nativeExecutablesState: RegistryPackageVersionNativeExecutablesStateChoices!

  """List of direct dependencies of this package version"""
  dependencies(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  deployappversionSet(offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  lastversionPackage(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  commands: [Command!]!
  nativeexecutableSet(offset: Int, before: String, after: String, first: Int, last: Int): NativeExecutableConnection!
  bindingsgeneratorSet(offset: Int, before: String, after: String, first: Int, last: Int): BindingsGeneratorConnection!
  javascriptlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  pythonlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
  piritaFile: String @deprecated(reason: "Please use distribution.piritaDownloadUrl instead.")
  piritaFileSize: Int @deprecated(reason: "Please use distribution.piritaSize instead.")
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  pirita256hash: String @deprecated(reason: "Please use distribution.piritaSha256Hash instead.")
  distribution: PackageDistribution!
  filesystem: [PackageVersionFilesystem]!
  isLastVersion: Boolean!
  witFile: String
  isSigned: Boolean!
  moduleInterfaces: [InterfaceVersion!]!
  modules: [PackageVersionModule!]!
  getPiritaContents(volume: String! = "atom", base: String! = ""): [PiritaFilesystemItem!]!
  getWebcContents(volume: String! = "atom", base: String! = "/"): [WEBCFilesystemItem!]!
  nativeExecutables(triple: String, wasmerCompilerVersion: String): [NativeExecutable]
  bindings: [PackageVersionLanguageBinding]!
  npmBindings: PackageVersionNPMBinding
  pythonBindings: PackageVersionPythonBinding
  hasBindings: Boolean!
  hasCommands: Boolean!
  showDeployButton: Boolean!
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

type WebcImage implements Node {
  """The ID of the object"""
  id: ID!

  """"""
  fileSize: BigInt!
  manifest: JSONString!
  volumes: JSONString!
  offsets: JSONString!
  webcSha256: String!
  targzSha256: String
  createdAt: DateTime!
  updatedAt: DateTime!
  webcUrl: String!
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

enum RegistryPackageVersionBindingsStateChoices {
  """Bindings are not detected"""
  NOT_PRESENT

  """Bindings are being built"""
  GENERATING

  """Bindings generation has failed"""
  ERROR

  """Bindings are built and present"""
  GENERATED_AND_PRESENT
}

enum RegistryPackageVersionNativeExecutablesStateChoices {
  """Native Executables are not detected"""
  NOT_PRESENT

  """Native Executables are being built"""
  GENERATING

  """Native Executables generation has failed"""
  ERROR

  """Native Executables are built and present"""
  GENERATED_AND_PRESENT
}

type PackageVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersion` and its cursor."""
type PackageVersionEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployAppVersion` and its cursor."""
type DeployAppVersionEdge {
  """The item at the end of the edge"""
  node: DeployAppVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppVersion implements Node {
  """The ID of the object"""
  id: ID!
  app: DeployApp!
  yamlConfig: String!
  userYamlConfig: String!
  clientName: String
  signature: String
  description: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  configWebc: String @deprecated(reason: "webc support has been deprecated for apps")
  config: String! @deprecated(reason: "Please use jsonConfig instead")
  jsonConfig: String!
  url: String!
  permalink: String!
  urls: [String]!
  version: String!
  isActive: Boolean!
  manifest: String!
  logs(
    """
    Get logs starting from this timestamp. Takes EPOCH timestamp in seconds.
    """
    startingFrom: Float

    """Get logs starting from this timestamp. Takes ISO timestamp."""
    startingFromISO: DateTime

    """Fetch logs until this timestamp. Takes EPOCH timestamp in seconds."""
    until: Float
    before: String
    after: String
    first: Int
    last: Int
  ): LogConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  sourcePackageVersion: PackageVersion!
  aggregateMetrics: AggregateMetrics!
}

type DeployApp implements Node & Owner {
  """The ID of the object"""
  id: ID!
  createdBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  activeVersion: DeployAppVersion!
  globalName: String!
  globalId: ID!
  url: String!
  adminUrl: String!
  permalink: String!
  urls: [String]!
  description: String
  name: String!
  owner: Owner!
  versions(sortBy: DeployAppVersionsSortBy, createdAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  aggregateMetrics: AggregateMetrics!
  aliases(offset: Int, before: String, after: String, first: Int, last: Int): AppAliasConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  deleted: Boolean!
}

enum DeployAppVersionsSortBy {
  NEWEST
  OLDEST
}

type AggregateMetrics {
  cpuTime: String!
  memoryTime: String!
  ingress: String!
  egress: String!
  noRequests: String!
  monthlyCost: String!
}

type AppAliasConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppAliasEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppAlias` and its cursor."""
type AppAliasEdge {
  """The item at the end of the edge"""
  node: AppAlias

  """A cursor for use in pagination"""
  cursor: String!
}

type AppAlias implements Node {
  name: String!
  app: DeployApp!
  isDefault: Boolean!

  """The ID of the object"""
  id: ID!
  url: String!
}

type UsageMetric {
  variant: MetricType!
  value: Float!
  unit: MetricUnit!
  timestamp: DateTime!
}

enum MetricType {
  cpu_time
  memory_time
  network_egress
  network_ingress
  no_of_requests
  cost
}

"""Units for metrics"""
enum MetricUnit {
  """represents the unit of "seconds"."""
  SEC

  """represents the unit of "kilobytes"."""
  KB

  """represents the unit of "kilobytes per second"."""
  KBS

  """represents the unit of "number of requests"."""
  NO_REQUESTS

  """represents the unit of "cost" in USD."""
  DOLLARS
}

enum MetricRange {
  LAST_24_HOURS
  LAST_30_DAYS
}

type LogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LogEdge]!
}

"""A Relay edge containing a `Log` and its cursor."""
type LogEdge {
  """The item at the end of the edge"""
  node: Log

  """A cursor for use in pagination"""
  cursor: String!
}

type Command {
  command: String!
  packageVersion: PackageVersion!
  module: PackageVersionModule!
}

type PackageVersionModule {
  name: String!
  source: String!
  abi: String
  publicUrl: String!
  atom: PiritaFilesystemFile!
  rangeHeader: String!
}

type PiritaFilesystemFile {
  name(display: PiritaFilesystemNameDisplay): String!
  size: Int!
  offset: Int!
}

enum PiritaFilesystemNameDisplay {
  RELATIVE
  ABSOLUTE
}

type NativeExecutableConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NativeExecutableEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NativeExecutable` and its cursor."""
type NativeExecutableEdge {
  """The item at the end of the edge"""
  node: NativeExecutable

  """A cursor for use in pagination"""
  cursor: String!
}

type NativeExecutable implements Node {
  """The ID of the object"""
  id: ID!
  module: String! @deprecated(reason: "Use filename instead")
  filename: String!
  filesize: Int!
  targetTriple: String!
  downloadUrl: String!
}

type BindingsGeneratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BindingsGeneratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BindingsGenerator` and its cursor."""
type BindingsGeneratorEdge {
  """The item at the end of the edge"""
  node: BindingsGenerator

  """A cursor for use in pagination"""
  cursor: String!
}

type BindingsGenerator implements Node {
  """The ID of the object"""
  id: ID!
  packageVersion: PackageVersion!
  active: Boolean!
  commandName: String!
  registryJavascriptlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  registryPythonlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
}

type PackageVersionNPMBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionNPMBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersionNPMBinding` and its cursor."""
type PackageVersionNPMBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionNPMBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionNPMBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  npmDefaultInstallPackageName(url: String): String! @deprecated(reason: "Please use packageName instead")
}

interface PackageVersionLanguageBinding {
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
}

enum ProgrammingLanguage {
  PYTHON
  JAVASCRIPT
}

type PackageVersionPythonBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionPythonBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `PackageVersionPythonBinding` and its cursor.
"""
type PackageVersionPythonBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionPythonBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionPythonBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  pythonDefaultInstallPackageName(url: String): String!
}

type PackageDistribution {
  """
  Download URL of the tar.gz file.
  If the package was published with webc only,this will contain download URL for webc file instead.
  """
  downloadUrl: String!
  expiresInSeconds: Int
  size: Int
  piritaDownloadUrl: String
  piritaExpiresInSeconds: Int
  piritaSize: Int
  piritaSha256Hash: String
  webcDownloadUrl: String
  webcExpiresInSeconds: Int
  webcSize: Int
  webcSha256Hash: String
}

type PackageVersionFilesystem {
  wasm: String!
  host: String!
}

type InterfaceVersion implements Node {
  """The ID of the object"""
  id: ID!
  interface: Interface!
  version: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedBy: User!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
}

type Interface implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  displayName: String!
  description: String!
  homepage: String
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
  versions(offset: Int, before: String, after: String, first: Int, last: Int): InterfaceVersionConnection!
  lastVersion: InterfaceVersion
}

type InterfaceVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InterfaceVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `InterfaceVersion` and its cursor."""
type InterfaceVersionEdge {
  """The item at the end of the edge"""
  node: InterfaceVersion

  """A cursor for use in pagination"""
  cursor: String!
}

union PiritaFilesystemItem = PiritaFilesystemFile | PiritaFilesystemDir

type PiritaFilesystemDir {
  name(display: PiritaFilesystemNameDisplay): String!
}

type WEBCFilesystemItem {
  name: String!
  checksum: String!
  size: Int!
  offset: Int!
}

type WebcImageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WebcImageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `WebcImage` and its cursor."""
type WebcImageEdge {
  """The item at the end of the edge"""
  node: WebcImage

  """A cursor for use in pagination"""
  cursor: String!
}

type Collection {
  slug: String!
  displayName: String!
  description: String!
  createdAt: DateTime!
  banner: String!
  packages(before: String, after: String, first: Int, last: Int): PackageConnection!
}

type CategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Category` and its cursor."""
type CategoryEdge {
  """The item at the end of the edge"""
  node: Category

  """A cursor for use in pagination"""
  cursor: String!
}

type Category implements Node {
  """The ID of the object"""
  id: ID!

  """A category is a label that can be attached to a package."""
  name: String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
}

type PackageKeywordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageKeywordEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageKeyword` and its cursor."""
type PackageKeywordEdge {
  """The item at the end of the edge"""
  node: PackageKeyword

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageKeyword implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
}

type PackageCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaborator` and its cursor."""
type PackageCollaboratorEdge {
  """The item at the end of the edge"""
  node: PackageCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryPackageMaintainerRoleChoices!
  package: Package!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: PackageCollaboratorInvite
}

enum RegistryPackageMaintainerRoleChoices {
  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  package: Package!
  role: RegistryPackageMaintainerInviteRoleChoices!
  accepted: PackageCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryPackageMaintainerInviteRoleChoices {
  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaboratorInvite` and its cursor."""
type PackageCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: PackageCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

enum GrapheneRole {
  ADMIN
  EDITOR
  VIEWER
}

type PackageTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  package: Package!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: PackageOwner!
  newOwner: PackageOwner!
}

type PackageSearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageSearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PackageSearch` and its cursor."""
type PackageSearchEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployApp` and its cursor."""
type DeployAppEdge {
  """The item at the end of the edge"""
  node: DeployApp

  """A cursor for use in pagination"""
  cursor: String!
}

enum DeployAppsSortBy {
  NEWEST
  OLDEST
  MOST_ACTIVE
}

type NamespaceCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NamespaceCollaborator` and its cursor."""
type NamespaceCollaboratorEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageTransferRequestConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageTransferRequestEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageTransferRequest` and its cursor."""
type PackageTransferRequestEdge {
  """The item at the end of the edge"""
  node: PackageTransferRequest

  """A cursor for use in pagination"""
  cursor: String!
}

type APITokenConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [APITokenEdge]!
}

"""A Relay edge containing a `APIToken` and its cursor."""
type APITokenEdge {
  """The item at the end of the edge"""
  node: APIToken

  """A cursor for use in pagination"""
  cursor: String!
}

type APIToken {
  id: ID!
  user: User!
  identifier: String
  createdAt: DateTime!
  revokedAt: DateTime
  lastUsedAt: DateTime
  nonceSet(offset: Int, before: String, after: String, first: Int, last: Int): NonceConnection!
}

type NonceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NonceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Nonce` and its cursor."""
type NonceEdge {
  """The item at the end of the edge"""
  node: Nonce

  """A cursor for use in pagination"""
  cursor: String!
}

type Nonce implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  callbackUrl: String!
  createdAt: DateTime!
  isValidated: Boolean!
  secret: String!
  token: String!
  expired: Boolean!
  authUrl: String!
}

type UserNotificationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserNotificationEdge]!
  hasPendingNotifications: Boolean!
  pendingNotificationsCount: Int!
}

"""A Relay edge containing a `UserNotification` and its cursor."""
type UserNotificationEdge {
  """The item at the end of the edge"""
  node: UserNotification

  """A cursor for use in pagination"""
  cursor: String!
}

type UserNotification implements Node {
  """The ID of the object"""
  id: ID!
  icon: String
  body: EventBody!
  seenState: UserNotificationSeenState!
  kind: UserNotificationKind
  createdAt: DateTime!
}

enum UserNotificationSeenState {
  UNSEEN
  SEEN
  SEEN_AND_READ
}

union UserNotificationKind = UserNotificationKindPublishedPackageVersion | UserNotificationKindIncomingPackageTransfer | UserNotificationKindIncomingPackageInvite | UserNotificationKindIncomingNamespaceInvite | UserNotificationKindValidateEmail

type UserNotificationKindPublishedPackageVersion {
  packageVersion: PackageVersion!
}

type UserNotificationKindIncomingNamespaceInvite {
  namespaceInvite: NamespaceCollaboratorInvite!
}

type UserNotificationKindValidateEmail {
  user: User!
}

"""

    Enum of ways a user can login. One user can have many login methods
    associated with their account.
    
"""
enum LoginMethod {
  GOOGLE
  GITHUB
  PASSWORD
}

type Signature {
  id: ID!
  publicKey: PublicKey!
  data: String!
  createdAt: DateTime!
}

type UserNotificationKindIncomingPackageTransfer {
  packageTransferRequest: PackageTransferRequest!
}

type UserNotificationKindIncomingPackageInvite {
  packageInvite: PackageCollaboratorInvite!
}

input DeploymentV1 {
  name: String!
  workload: WorkloadV1!
}

input WorkloadV1 {
  capability: CapabilityMapV1
  name: String = null
  runner: WorkloadRunnerV1!
}

input AppV1Spec {
  aliases: [String] = []
  workload: WorkloadV2!
}

input WorkloadV2 {
  source: String!
}

input CapabilityCpuV1 {
  maximumThreads: Int
  maximumUsage: Int
}

input FileSystemPermissionsV1 {
  delete: Boolean
  read: Boolean
  write: Boolean
}

input FileSystemVolumeMountV1 {
  path: String!
  permissions: [FileSystemPermissionsV1]
}

input FileSystemVolumeSourceLocalV1 {
  maximumSize: String!
}

input FileSystemVolumeSourceV1 {
  local: FileSystemVolumeSourceLocalV1!
}

input FileSystemVolumeConfigV1 {
  mounts: [FileSystemVolumeMountV1]!
  name: String!
  source: FileSystemVolumeSourceV1!
}

input CapabilityFileSystemV1 {
  volumes: [FileSystemVolumeConfigV1]!
}

input CapabilityPersistentMemoryV1 {
  volumes: [String]
}

input CapabilityMemorySwapV1 {
  maximumSize: String
  memoryId: String
}

input CapabilityNetworkV1 {
  egress: NetworkEgressV1
}

input NetworkEgressV1 {
  enabled: Boolean
}

input CapabilityNetworkDnsV1 {
  enabled: Boolean
  servers: [String]
  allowedHosts: NetworkDnsAllowedHostsV1
}

input NetworkDnsAllowedHostsV1 {
  allowAllHosts: Boolean
  hosts: [String]
  regexPatterns: [String]
  wildcardPatterns: [String]
}

input CapabilityNetworkGatewayV1 {
  domains: [String]
  enforceHttps: Boolean
}

input CapabilityMapV1 {
  memorySwap: CapabilityCpuV1
}

input WebcSourceV1 {
  name: String!
  namespace: String!
  repository: String! = "https://registry.wasmer.wtf"
  tag: String
  authToken: String
}

input WorkloadRunnerV1 {
  webProxy: RunnerWebProxyV1
  wcgi: RunnerWCGIV1
}

"""Run a webassembly file."""
input RunnerWCGIV1 {
  source: WorkloadRunnerWasmSourceV1!
  dialect: String
}

input RunnerWebProxyV1 {
  source: WorkloadRunnerWasmSourceV1!
}

input WorkloadRunnerWasmSourceV1 {
  webc: WebcSourceV1!
}

type StripeCustomer {
  id: ID!
}

type Billing {
  stripeCustomer: StripeCustomer!
  payments: [PaymentIntent]!
  paymentMethods: [PaymentMethod]!
}

type PaymentIntent implements Node {
  """The datetime this object was created in stripe."""
  created: DateTime

  """Three-letter ISO currency code"""
  currency: String!

  """
  Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.
  """
  status: DjstripePaymentIntentStatusChoices!

  """The ID of the object"""
  id: ID!
  amount: String!
}

enum DjstripePaymentIntentStatusChoices {
  """
  Cancellation invalidates the intent for future confirmation and cannot be undone.
  """
  CANCELED

  """Required actions have been handled."""
  PROCESSING

  """Payment Method require additional action, such as 3D secure."""
  REQUIRES_ACTION

  """Capture the funds on the cards which have been put on holds."""
  REQUIRES_CAPTURE

  """Intent is ready to be confirmed."""
  REQUIRES_CONFIRMATION

  """Intent created and requires a Payment Method to be attached."""
  REQUIRES_PAYMENT_METHOD

  """The funds are in your account."""
  SUCCEEDED
}

union PaymentMethod = CardPaymentMethod

type CardPaymentMethod implements Node {
  """The ID of the object"""
  id: ID!
  brand: CardBrand!
  country: String!
  expMonth: Int!
  expYear: Int!
  funding: CardFunding!
  last4: String!
  isDefault: Boolean!
}

"""
Card brand.

Can be amex, diners, discover, jcb, mastercard, unionpay, visa, or unknown.
"""
enum CardBrand {
  AMEX
  DINERS
  DISCOVER
  JCB
  MASTERCARD
  UNIONPAY
  VISA
  UNKNOWN
}

"""
Card funding type.

Can be credit, debit, prepaid, or unknown.
"""
enum CardFunding {
  CREDIT
  DEBIT
  PREPAID
  UNKNOWN
}

type Payment {
  id: ID
  amount: String
  paidOn: DateTime
}

"""Log entry for deploy app."""
type Log {
  """Timestamp in nanoseconds"""
  timestamp: Float!

  """ISO 8601 string in UTC"""
  datetime: DateTime!

  """Log message"""
  message: String!
}

type Query {
  latestTOS: TermsOfService!
  getDeployAppVersion(name: String!, owner: String, version: String): DeployAppVersion
  getDeployApp(name: String!, owner: String): DeployApp
  getAppByGlobalAlias(alias: String!): DeployApp
  getDeployApps(sortBy: DeployAppsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  getAppVersions(sortBy: DeployAppVersionsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  getAppTemplates(categorySlug: String, offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
  getAppTemplate(slug: String!): AppTemplate!
  getAppTemplateCategories(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateCategoryConnection!
  viewer: User
  getUser(username: String!): User
  getPasswordResetToken(token: String!): GetPasswordResetToken
  getAuthNonce(name: String!): Nonce
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
  recentPackageVersions(curated: Boolean, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  allPackageVersions(sortBy: PackageVersionSortBy, createdAfter: DateTime, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  getWebcImage(hash: String!): WebcImage
  getNamespace(name: String!): Namespace
  getPackage(name: String!): Package
  getPackages(names: [String!]!): [Package]!
  getPackageVersion(name: String!, version: String = "latest"): PackageVersion
  getPackageVersions(names: [String!]!): [PackageVersion]
  getPackageVersionByHash(name: String!, hash: String!): PackageVersion
  getInterface(name: String!): Interface
  getInterfaces(names: [String!]!): [Interface]!
  getInterfaceVersion(name: String!, version: String = "latest"): InterfaceVersion
  getContract(name: String!): Interface @deprecated(reason: "Please use getInterface instead")
  getContracts(names: [String!]!): [Interface]! @deprecated(reason: "Please use getInterfaces instead")
  getContractVersion(name: String!, version: String): InterfaceVersion @deprecated(reason: "Please use getInterfaceVersion instead")
  getCommand(name: String!): Command
  getCommands(names: [String!]!): [Command]
  getCollections(before: String, after: String, first: Int, last: Int): CollectionConnection
  getSignedUrlForPackageUpload(name: String!, version: String = "latest", expiresAfterSeconds: Int = 60): SignedUrl
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  blogposts(tags: [String!], before: String, after: String, first: Int, last: Int): BlogPostConnection!
  getBlogpost(slug: String, featured: Boolean): BlogPost
  allBlogpostTags(offset: Int, before: String, after: String, first: Int, last: Int): BlogPostTagConnection
  search(query: String!, packages: PackagesFilter, namespaces: NamespacesFilter, users: UsersFilter, apps: AppFilter, blogposts: BlogPostsFilter, before: String, after: String, first: Int, last: Int): SearchConnection!
  searchAutocomplete(kind: [SearchKind!], query: String!, before: String, after: String, first: Int, last: Int): SearchConnection!
  getGlobalObject(slug: String!): GlobalObject
  node(
    """The ID of the object"""
    id: ID!
  ): Node
  nodes(ids: [ID!]!): [Node]
  info: RegistryInfo
}

type TermsOfService implements Node {
  """The ID of the object"""
  id: ID!
  content: String!
  createdAt: DateTime!
  viewerHasAccepted: Boolean!
}

type AppTemplateConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplate` and its cursor."""
type AppTemplateEdge {
  """The item at the end of the edge"""
  node: AppTemplate

  """A cursor for use in pagination"""
  cursor: String!
}

type AppTemplate implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  demoUrl: String!
  repoUrl: String!
  defaultImage: String
  category: AppTemplateCategory!
  isPublic: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  readme: String!
}

type AppTemplateCategory implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  appTemplates(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
}

type AppTemplateCategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateCategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplateCategory` and its cursor."""
type AppTemplateCategoryEdge {
  """The item at the end of the edge"""
  node: AppTemplateCategory

  """A cursor for use in pagination"""
  cursor: String!
}

type GetPasswordResetToken {
  valid: Boolean!
  user: User
}

enum PackageVersionSortBy {
  NEWEST
  OLDEST
}

type CollectionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CollectionEdge]!
}

"""A Relay edge containing a `Collection` and its cursor."""
type CollectionEdge {
  """The item at the end of the edge"""
  node: Collection

  """A cursor for use in pagination"""
  cursor: String!
}

type SignedUrl {
  url: String!
}

type BlogPostConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostEdge]!
}

"""A Relay edge containing a `BlogPost` and its cursor."""
type BlogPostEdge {
  """The item at the end of the edge"""
  node: BlogPost

  """A cursor for use in pagination"""
  cursor: String!
}

type BlogPost implements Node {
  """The ID of the object"""
  id: ID!
  live: Boolean!

  """The page title as you'd like it to be seen by the public"""
  title: String!

  """
  The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/
  """
  slug: String!
  owner: User
  body: String!
  publishDate: DateTime
  theme: BlogBlogPostThemeChoices!
  url: String!
  coverImageUrl: String
  opengraphImageUrl: String
  tagline: String!
  relatedArticles: [BlogPost!]
  updatedAt: DateTime!
  tags: [BlogPostTag!]
  editUrl: String
}

enum BlogBlogPostThemeChoices {
  """Green"""
  GREEN

  """Purple"""
  PURPLE

  """Orange"""
  ORANGE

  """Blue"""
  BLUE
}

type BlogPostTag implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
}

type BlogPostTagConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostTagEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BlogPostTag` and its cursor."""
type BlogPostTagEdge {
  """The item at the end of the edge"""
  node: BlogPostTag

  """A cursor for use in pagination"""
  cursor: String!
}

type SearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Search` and its cursor."""
type SearchEdge {
  """The item at the end of the edge"""
  node: SearchResult

  """A cursor for use in pagination"""
  cursor: String!
}

union SearchResult = PackageVersion | User | Namespace | DeployApp | BlogPost

input PackagesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter packages by being curated."""
  curated: Boolean

  """Filter packages by publish date."""
  publishDate: SearchPublishDate

  """Filter packages by having bindings."""
  hasBindings: Boolean = false

  """Filter packages by being standalone."""
  isStandalone: Boolean = false

  """Filter packages by having commands."""
  hasCommands: Boolean = false

  """Filter packages by interface."""
  withInterfaces: [String]

  """Filter packages by deployable status."""
  deployable: Boolean

  """Filter packages by license."""
  license: String

  """Filter packages created after this date."""
  createdAfter: DateTime

  """Filter packages created before this date."""
  createdBefore: DateTime

  """Filter packages with version published after this date."""
  lastPublishedAfter: DateTime

  """Filter packages with version published before this date."""
  lastPublishedBefore: DateTime

  """Filter packages by size."""
  size: CountFilter

  """Filter packages by download count."""
  downloads: CountFilter

  """Filter packages by like count."""
  likes: CountFilter

  """Filter packages by owner."""
  owner: String

  """Filter packages by published by."""
  publishedBy: String

  """Order packages by field."""
  orderBy: PackageOrderBy = PUBLISHED_DATE
}

enum SearchOrderSort {
  ASC
  DESC
}

enum SearchPublishDate {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_YEAR
}

input CountFilter {
  count: Int = 0
  comparison: CountComparison = GREATER_THAN_OR_EQUAL
}

enum CountComparison {
  EQUAL
  GREATER_THAN
  LESS_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
}

enum PackageOrderBy {
  ALPHABETICALLY
  SIZE
  TOTAL_DOWNLOADS
  PUBLISHED_DATE
  CREATED_DATE
  TOTAL_LIKES
}

input NamespacesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter namespaces by package count."""
  packageCount: CountFilter

  """Filter namespaces created after this date."""
  createdAfter: DateTime

  """Filter namespaces created before this date."""
  createdBefore: DateTime

  """Filter namespaces by user count."""
  userCount: CountFilter

  """Filter namespaces by collaborator."""
  collaborator: String

  """Order namespaces by field."""
  orderBy: NamespaceOrderBy = CREATED_DATE
}

enum NamespaceOrderBy {
  PACKAGE_COUNT
  COLLABORATOR_COUNT
  APP_COUNT
  CREATED_DATE
}

input UsersFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter users by package count."""
  packageCount: CountFilter

  """Filter users by namespace count."""
  namespaceCount: CountFilter

  """Filter users joined after this date."""
  joinedAfter: DateTime

  """Filter users joined before this date."""
  joinedBefore: DateTime

  """Order users by field."""
  orderBy: UserOrderBy = CREATED_DATE
}

enum UserOrderBy {
  PACKAGE_COUNT
  APP_COUNT
  CREATED_DATE
}

input AppFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter apps by deployed by."""
  deployedBy: String

  """Filter apps last deployed after this date."""
  lastDeployedAfter: DateTime

  """Filter apps last deployed before this date."""
  lastDeployedBefore: DateTime

  """Filter apps by owner."""
  owner: String

  """Order apps by field."""
  orderBy: AppOrderBy = CREATED_DATE

  """Filter apps by client name."""
  clientName: String
}

enum AppOrderBy {
  PUBLISHED_DATE
  CREATED_DATE
}

input BlogPostsFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter blog posts by tag."""
  tags: [String]
}

enum SearchKind {
  PACKAGE
  NAMESPACE
  USER
}

union GlobalObject = User | Namespace

type RegistryInfo {
  """Base URL for this registry"""
  baseUrl: String!

  """Base URL for the default frontend"""
  defaultFrontend: String!

  """URL to the graphql endpoint"""
  graphqlUrl: String!

  """URL to the graphql endpoint"""
  createBlogpostUrl: String

  """Public metadata about packages"""
  packages: PackageInfo!

  """Public metadata about the graphql schema"""
  schema: SchemaInfo!
}

type PackageInfo {
  """Number of package versions published this month"""
  versionsPublishedThisMonth: Int!

  """Number of new packages published this month"""
  newPackagesThisMonth: Int!

  """Number of package downloads this month"""
  packageDownloadsThisMonth: Int!
}

type SchemaInfo {
  """Download link for graphql schema"""
  downloadUrl: String!

  """SHA256 hash of the schema data"""
  SHA256Hash: String!

  """Timestamp when the schema was last updated"""
  lastUpdated: DateTime!
}

type Mutation {
  """Viewer accepts the latest ToS."""
  acceptTOS(input: AcceptTOSInput!): AcceptTOSPayload
  publishDeployApp(input: PublishDeployAppInput!): PublishDeployAppPayload
  deleteApp(input: DeleteAppInput!): DeleteAppPayload

  """Add current user to the waitlist."""
  joinWaitlist(input: JoinWaitlistInput!): JoinWaitlistPayload

  """Add stripe payment to the user"""
  addPayment(input: AddPaymentInput!): AddPaymentPayload

  """
  Mutation to change the active version of a DeployApp to another DeployAppVersion.
  """
  markAppVersionAsActive(input: MarkAppVersionAsActiveInput!): MarkAppVersionAsActivePayload

  """Set a payment method as default for the user."""
  makePaymentDefault(input: SetDefaultPaymentMethodInput!): SetDefaultPaymentMethodPayload

  """
  Try to detach a payment method from customer.
  Fails if trying to detach a default method,
  or if it's the only payment method.
  """
  detachPaymentMethod(input: DetachPaymentMethodInput!): DetachPaymentMethodPayload
  generateDeployConfigToken(input: GenerateDeployConfigTokenInput!): GenerateDeployConfigTokenPayload
  renameApp(input: RenameAppInput!): RenameAppPayload
  renameAppAlias(input: RenameAppAliasInput!): RenameAppAliasPayload
  requestAppTransfer(input: RequestAppTransferInput!): RequestAppTransferPayload
  acceptAppTransferRequest(input: AcceptAppTransferRequestInput!): AcceptAppTransferRequestPayload
  removeAppTransferRequest(input: RemoveAppTransferRequestInput!): RemoveAppTransferRequestPayload
  createRepoForAppTemplate(input: CreateRepoForAppTemplateInput!): CreateRepoForAppTemplatePayload
  tokenAuth(input: ObtainJSONWebTokenInput!): ObtainJSONWebTokenPayload
  generateDeployToken(input: GenerateDeployTokenInput!): GenerateDeployTokenPayload
  verifyAccessToken(token: String): Verify
  refreshAccessToken(refreshToken: String): Refresh
  revokeAccessToken(refreshToken: String): Revoke
  registerUser(input: RegisterUserInput!): RegisterUserPayload
  socialAuth(input: SocialAuthJWTInput!): SocialAuthJWTPayload
  validateUserEmail(input: ValidateUserEmailInput!): ValidateUserEmailPayload
  requestPasswordReset(input: RequestPasswordResetInput!): RequestPasswordResetPayload
  requestValidationEmail(input: RequestValidationEmailInput!): RequestValidationEmailPayload
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload
  changeUserUsername(input: ChangeUserUsernameInput!): ChangeUserUsernamePayload
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayload
  validateUserPassword(input: ValidateUserPasswordInput!): ValidateUserPasswordPayload
  generateApiToken(input: GenerateAPITokenInput!): GenerateAPITokenPayload
  revokeApiToken(input: RevokeAPITokenInput!): RevokeAPITokenPayload
  checkUserExists(input: CheckUserExistsInput!): CheckUserExistsPayload
  readNotification(input: ReadNotificationInput!): ReadNotificationPayload
  seePendingNotifications(input: SeePendingNotificationsInput!): SeePendingNotificationsPayload
  newNonce(input: NewNonceInput!): NewNoncePayload
  validateNonce(input: ValidateNonceInput!): ValidateNoncePayload
  publishPublicKey(input: PublishPublicKeyInput!): PublishPublicKeyPayload
  publishPackage(input: PublishPackageInput!): PublishPackagePayload
  updatePackage(input: UpdatePackageInput!): UpdatePackagePayload
  likePackage(input: LikePackageInput!): LikePackagePayload
  unlikePackage(input: UnlikePackageInput!): UnlikePackagePayload
  watchPackage(input: WatchPackageInput!): WatchPackagePayload
  unwatchPackage(input: UnwatchPackageInput!): UnwatchPackagePayload
  archivePackage(input: ArchivePackageInput!): ArchivePackagePayload
  changePackageVersionArchivedStatus(input: ChangePackageVersionArchivedStatusInput!): ChangePackageVersionArchivedStatusPayload
  createNamespace(input: CreateNamespaceInput!): CreateNamespacePayload
  updateNamespace(input: UpdateNamespaceInput!): UpdateNamespacePayload
  deleteNamespace(input: DeleteNamespaceInput!): DeleteNamespacePayload
  inviteNamespaceCollaborator(input: InviteNamespaceCollaboratorInput!): InviteNamespaceCollaboratorPayload
  acceptNamespaceCollaboratorInvite(input: AcceptNamespaceCollaboratorInviteInput!): AcceptNamespaceCollaboratorInvitePayload
  removeNamespaceCollaboratorInvite(input: RemoveNamespaceCollaboratorInviteInput!): RemoveNamespaceCollaboratorInvitePayload
  removeNamespaceCollaborator(input: RemoveNamespaceCollaboratorInput!): RemoveNamespaceCollaboratorPayload
  updateNamespaceCollaboratorRole(input: UpdateNamespaceCollaboratorRoleInput!): UpdateNamespaceCollaboratorRolePayload
  updateNamespaceCollaboratorInviteRole(input: UpdateNamespaceCollaboratorInviteRoleInput!): UpdateNamespaceCollaboratorInviteRolePayload
  invitePackageCollaborator(input: InvitePackageCollaboratorInput!): InvitePackageCollaboratorPayload
  acceptPackageCollaboratorInvite(input: AcceptPackageCollaboratorInviteInput!): AcceptPackageCollaboratorInvitePayload
  removePackageCollaboratorInvite(input: RemovePackageCollaboratorInviteInput!): RemovePackageCollaboratorInvitePayload
  updatePackageCollaboratorRole(input: UpdatePackageCollaboratorRoleInput!): UpdatePackageCollaboratorRolePayload
  updatePackageCollaboratorInviteRole(input: UpdatePackageCollaboratorInviteRoleInput!): UpdatePackageCollaboratorInviteRolePayload
  removePackageCollaborator(input: RemovePackageCollaboratorInput!): RemovePackageCollaboratorPayload
  requestPackageTransfer(input: RequestPackageTransferInput!): RequestPackageTransferPayload
  acceptPackageTransferRequest(input: AcceptPackageTransferRequestInput!): AcceptPackageTransferRequestPayload
  removePackageTransferRequest(input: RemovePackageTransferRequestInput!): RemovePackageTransferRequestPayload
  generateBindingsForAllPackages(input: GenerateBindingsForAllPackagesInput!): GenerateBindingsForAllPackagesPayload
  makePackagePublic(input: MakePackagePublicInput!): MakePackagePublicPayload
}

"""Viewer accepts the latest ToS."""
type AcceptTOSPayload {
  TOS: TermsOfService!
  clientMutationId: String
}

input AcceptTOSInput {
  clientMutationId: String
}

type PublishDeployAppPayload {
  deployAppVersion: DeployAppVersion!
  clientMutationId: String
}

input PublishDeployAppInput {
  """The configuration of the app."""
  config: Configuration!

  """The name of the app."""
  name: ID

  """The owner of the app."""
  owner: ID

  """The description of the app."""
  description: String

  """If true, the new version will be set as the default version."""
  makeDefault: Boolean = true

  """
  If true, Publishing will fail if the source package does not have a valid webc.
  """
  strict: Boolean = false
  clientMutationId: String
}

input Configuration {
  deployment: AppV0
  yamlConfig: String
}

input AppV0 {
  kind: String = "wasmer.io/App.v0"
  appId: ID
  name: String!
  description: String
  package: String!
}

type DeleteAppPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteAppInput {
  """App ID to delete."""
  id: ID!
  clientMutationId: String
}

"""Add current user to the waitlist."""
type JoinWaitlistPayload {
  waitlistMember: WaitlistMember!
  clientMutationId: String
}

input JoinWaitlistInput {
  name: String!
  clientMutationId: String
}

"""Add stripe payment to the user"""
type AddPaymentPayload {
  customerSecret: String!
  clientMutationId: String
}

input AddPaymentInput {
  clientMutationId: String
}

"""
Mutation to change the active version of a DeployApp to another DeployAppVersion.
"""
type MarkAppVersionAsActivePayload {
  app: DeployApp!
  clientMutationId: String
}

input MarkAppVersionAsActiveInput {
  """The ID of the DeployAppVersion to set as the new active version."""
  appVersion: ID!
  clientMutationId: String
}

"""Set a payment method as default for the user."""
type SetDefaultPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input SetDefaultPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

"""
Try to detach a payment method from customer.
Fails if trying to detach a default method,
or if it's the only payment method.
"""
type DetachPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input DetachPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

type GenerateDeployConfigTokenPayload {
  token: String!
  config: String!
  clientMutationId: String
}

input GenerateDeployConfigTokenInput {
  config: String!
  clientMutationId: String
}

type RenameAppPayload {
  success: Boolean!
  app: DeployApp!
  clientMutationId: String
}

input RenameAppInput {
  """App ID to delete."""
  id: ID!

  """New name for the app."""
  name: String!
  clientMutationId: String
}

type RenameAppAliasPayload {
  success: Boolean!
  alias: AppAlias!
  clientMutationId: String
}

input RenameAppAliasInput {
  """App alias ID to delete."""
  id: ID!

  """New name for the alias."""
  name: String!
  clientMutationId: String
}

type RequestAppTransferPayload {
  appTransferRequest: AppTransferRequest
  clientMutationId: String
}

type AppTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  app: DeployApp!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: Owner!
  newOwner: Owner!
}

input RequestAppTransferInput {
  appId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptAppTransferRequestPayload {
  app: DeployApp!
  appTransferRequest: AppTransferRequest!
  clientMutationId: String
}

input AcceptAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type RemoveAppTransferRequestPayload {
  app: DeployApp!
  clientMutationId: String
}

input RemoveAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type CreateRepoForAppTemplatePayload {
  success: Boolean!
  app: DeployApp
  clientMutationId: String
}

input CreateRepoForAppTemplateInput {
  templateId: ID!
  name: String!
  namespace: String!
  clientMutationId: String
}

type ObtainJSONWebTokenPayload {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  username: CaseInsensitiveString!
  clientMutationId: String
  token: String!
  refreshToken: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
The `CaseInsensitiveString` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar CaseInsensitiveString

input ObtainJSONWebTokenInput {
  clientMutationId: String
  username: String!
  password: String!
}

type GenerateDeployTokenPayload {
  token: String!
  deployConfigVersion: DeployAppVersion!
  clientMutationId: String
}

input GenerateDeployTokenInput {
  deployConfigVersionId: String!
  clientMutationId: String
}

type Verify {
  payload: GenericScalar!
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

type Revoke {
  revoked: Int!
}

type RegisterUserPayload {
  token: String
  clientMutationId: String
}

input RegisterUserInput {
  fullName: String!
  email: String!
  username: CaseInsensitiveString!
  password: String!
  clientMutationId: String
}

type SocialAuthJWTPayload {
  social: SocialAuth
  token: String
  clientMutationId: String
}

type SocialAuth implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  provider: String!
  uid: String!
  extraData: String!
  created: DateTime!
  modified: DateTime!
}

input SocialAuthJWTInput {
  provider: String!
  accessToken: String!
  register: Boolean = false
  clientMutationId: String
}

type ValidateUserEmailPayload {
  user: User
  clientMutationId: String
}

input ValidateUserEmailInput {
  """The user id"""
  userId: ID
  challenge: String!
  clientMutationId: String
}

type RequestPasswordResetPayload {
  email: String!
  errors: [ErrorType]
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

input RequestPasswordResetInput {
  email: String!
  clientMutationId: String
}

type RequestValidationEmailPayload {
  user: User
  success: Boolean!
  clientMutationId: String
}

input RequestValidationEmailInput {
  """The user id"""
  userId: ID
  clientMutationId: String
}

type ChangeUserPasswordPayload {
  token: String
  clientMutationId: String
}

input ChangeUserPasswordInput {
  """
  The token associated to change the password. If not existing it will use the request user by default
  """
  token: String
  oldPassword: String
  password: String!
  clientMutationId: String
}

type ChangeUserUsernamePayload {
  user: User
  token: String
  clientMutationId: String
}

input ChangeUserUsernameInput {
  """The new user username"""
  username: CaseInsensitiveString!
  clientMutationId: String
}

type ChangeUserEmailPayload {
  user: User!
  clientMutationId: String
}

input ChangeUserEmailInput {
  newEmail: String!
  clientMutationId: String
}

type UpdateUserInfoPayload {
  user: User
  clientMutationId: String
}

input UpdateUserInfoInput {
  """The user id"""
  userId: ID

  """The user full name"""
  fullName: String

  """The user bio"""
  bio: String

  """The user avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String

  """The user location"""
  location: String
  clientMutationId: String
}

type ValidateUserPasswordPayload {
  success: Boolean
  clientMutationId: String
}

input ValidateUserPasswordInput {
  password: String!
  clientMutationId: String
}

type GenerateAPITokenPayload {
  token: APIToken
  tokenRaw: String
  user: User
  clientMutationId: String
}

input GenerateAPITokenInput {
  identifier: String
  clientMutationId: String
}

type RevokeAPITokenPayload {
  token: APIToken
  success: Boolean
  clientMutationId: String
}

input RevokeAPITokenInput {
  """The API token ID"""
  tokenId: ID!
  clientMutationId: String
}

type CheckUserExistsPayload {
  exists: Boolean!

  """The user is only returned if the user input was the username"""
  user: User
  clientMutationId: String
}

input CheckUserExistsInput {
  """The user"""
  user: String!
  clientMutationId: String
}

type ReadNotificationPayload {
  notification: UserNotification
  clientMutationId: String
}

input ReadNotificationInput {
  notificationId: ID!
  clientMutationId: String
}

type SeePendingNotificationsPayload {
  success: Boolean
  clientMutationId: String
}

input SeePendingNotificationsInput {
  clientMutationId: String
}

type NewNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input NewNonceInput {
  name: String!
  callbackUrl: String!
  clientMutationId: String
}

type ValidateNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input ValidateNonceInput {
  id: ID!
  secret: String!
  clientMutationId: String
}

type PublishPublicKeyPayload {
  success: Boolean!
  publicKey: PublicKey!
  clientMutationId: String
}

input PublishPublicKeyInput {
  keyId: String!
  key: String!
  verifyingSignatureId: String
  clientMutationId: String
}

type PublishPackagePayload {
  success: Boolean!
  packageVersion: PackageVersion!
  clientMutationId: String
}

input PublishPackageInput {
  name: String!
  version: String!
  description: String!
  manifest: String!
  license: String
  licenseFile: String
  readme: String
  repository: String
  homepage: String
  file: String
  signedUrl: String
  signature: InputSignature

  """The package icon"""
  icon: String

  """Whether the package is private"""
  private: Boolean = false

  """The upload format of the package"""
  uploadFormat: UploadFormat = targz

  """Whether to wait for webc generation to finish"""
  wait: Boolean = false
  clientMutationId: String
}

input InputSignature {
  publicKeyKeyId: String!
  data: String!
}

enum UploadFormat {
  targz
  webcv2
}

type UpdatePackagePayload {
  package: Package!
  clientMutationId: String
}

input UpdatePackageInput {
  packageId: ID!

  """The package icon"""
  icon: String
  clientMutationId: String
}

type LikePackagePayload {
  package: Package!
  clientMutationId: String
}

input LikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnlikePackagePayload {
  package: Package!
  clientMutationId: String
}

input UnlikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type WatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input WatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnwatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input UnwatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type ArchivePackagePayload {
  package: Package!
  clientMutationId: String
}

input ArchivePackageInput {
  packageId: ID!
  clientMutationId: String
}

type ChangePackageVersionArchivedStatusPayload {
  packageVersion: PackageVersion!
  clientMutationId: String
}

input ChangePackageVersionArchivedStatusInput {
  packageVersionId: ID!
  isArchived: Boolean
  clientMutationId: String
}

type CreateNamespacePayload {
  namespace: Namespace!
  user: User!
  clientMutationId: String
}

input CreateNamespaceInput {
  name: String!

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String
  clientMutationId: String
}

type UpdateNamespacePayload {
  namespace: Namespace!
  clientMutationId: String
}

input UpdateNamespaceInput {
  namespaceId: ID!

  """The namespace slug name"""
  name: String

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String
  clientMutationId: String
}

type DeleteNamespacePayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteNamespaceInput {
  namespaceId: ID!
  clientMutationId: String
}

type InviteNamespaceCollaboratorPayload {
  invite: NamespaceCollaboratorInvite!
  namespace: Namespace!
  clientMutationId: String
}

input InviteNamespaceCollaboratorInput {
  namespaceId: ID!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptNamespaceCollaboratorInvitePayload {
  namespaceCollaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input AcceptNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorInvitePayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorPayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInput {
  namespaceCollaboratorId: ID!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorRolePayload {
  collaborator: NamespaceCollaborator!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorRoleInput {
  namespaceCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorInviteRolePayload {
  collaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorInviteRoleInput {
  namespaceCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type InvitePackageCollaboratorPayload {
  invite: PackageCollaboratorInvite!
  package: Package!
  clientMutationId: String
}

input InvitePackageCollaboratorInput {
  packageName: String!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptPackageCollaboratorInvitePayload {
  packageCollaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input AcceptPackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemovePackageCollaboratorInvitePayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type UpdatePackageCollaboratorRolePayload {
  collaborator: PackageCollaborator!
  clientMutationId: String
}

input UpdatePackageCollaboratorRoleInput {
  packageCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdatePackageCollaboratorInviteRolePayload {
  collaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input UpdatePackageCollaboratorInviteRoleInput {
  packageCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type RemovePackageCollaboratorPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInput {
  packageCollaboratorId: ID!
  clientMutationId: String
}

type RequestPackageTransferPayload {
  package: Package!
  clientMutationId: String
}

input RequestPackageTransferInput {
  packageId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptPackageTransferRequestPayload {
  package: Package!
  packageTransferRequest: PackageTransferRequest!
  clientMutationId: String
}

input AcceptPackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type RemovePackageTransferRequestPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type GenerateBindingsForAllPackagesPayload {
  message: String!
  clientMutationId: String
}

input GenerateBindingsForAllPackagesInput {
  bindingsGeneratorId: ID
  bindingsGeneratorCommand: String
  clientMutationId: String
}

type MakePackagePublicPayload {
  package: Package!
  clientMutationId: String
}

input MakePackagePublicInput {
  """The ID of the package to make public"""
  id: ID!
  clientMutationId: String
}

type Subscription {
  streamLogs(
    appVersionId: ID!

    """
    Get logs starting from this timestamp. Takes ISO timestamp in UTC timezone.
    """
    startingFromISO: DateTime

    """
    Fetch logs until this timestamp. Takes ISO timestamp in UTC timezone. If specified, the subscription will at this time.
    """
    untilISO: DateTime
  ): Log!
  packageVersionCreated(publishedBy: ID, ownerId: ID): PackageVersion!

  """Subscribe to package version ready"""
  packageVersionReady(packageVersionId: ID!): PackageVersionReadyResponse!
  userNotificationCreated(userId: ID!): UserNotificationCreated!
}

type PackageVersionReadyResponse {
  state: PackageVersionState!
  packageVersion: PackageVersion!
  success: Boolean!
}

enum PackageVersionState {
  WEBC_GENERATED
  BINDINGS_GENERATED
  NATIVE_EXES_GENERATED
}

type UserNotificationCreated {
  notification: UserNotification
  notificationDeletedId: ID
}
